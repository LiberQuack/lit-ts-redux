{"version":3,"sources":["core/_definition.ts","application/definitions/person.ts","ui/pages/form-page.ts"],"names":[],"mappings":"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","file":"form-page.f406536c.js","sourceRoot":"../src","sourcesContent":["import {Constructor} from \"lit-element\";\n\nexport const DefinitionCssState = {\n    dirty: \"isDirty\",\n    valid: \"isValid\",\n    invalid: \"isInvalid\",\n};\n\nexport class Constraints {\n\n    /**\n     * Target result type, the value in plain object will be create by:\n     *\n     * [new] Type(fieldRawValue)\n     */\n    type = String as Constructor<any>;\n\n    /**\n     * Appears in plain Object\n     */\n    plainObject = true;\n\n    required = undefined as boolean;\n\n    /**\n     * Regex pattern to test the raw value set through model.set()\n     */\n    pattern = undefined as RegExp;\n\n    /**\n     * The last validation run, it receives raw value set by \"field.set(...)\"\n     * often you will need to parse the value.\n     *\n     * @example\n     * async (value) => Number(value) >= 18\n     */\n    extraValidation = undefined as (value: unknown) => Promise<boolean>;\n\n    constructor(config: Partial<Constraints>) {\n        Object.assign(this, config || {});\n    }\n\n    async validate(value): Promise<string | undefined> {\n        switch (true) {\n            case (!this.required && (value === null || value === undefined || value === \"\")):\n                break;\n\n            case (this.required && (value === null || value === undefined || value === \"\")):\n                return 'required';\n\n            case (this.pattern && !this.pattern.test(value)):\n                return 'pattern';\n\n            case (Boolean(this.extraValidation) && !(await this.extraValidation(value))):\n                return 'extra-validation'\n        }\n    }\n}\n\n\ntype PlainEnricher<T extends Constraints> = (model: Model<T>) => { [x: string]: any };\n\ntype DefineCallback<T extends Constraints> = (\n    define: (path: string, constraints: Partial<T>) => void,\n    validate?: (name: string, validator: (model: Model<T>) => Promise<Boolean>) => void,\n    plainObjEnricher?: (callback: (model: Model<T>) => {[x:string]: any}) => void,\n) => void;\n\nexport class Definition<T extends Constraints> {\n\n    private _definitions = {} as { [path: string]: T; };\n    private _validators = [] as { name: string, validator: ((model: Model<T>) => Promise<boolean>) }[];\n    private _constraint: { new(...args): T };\n    private _plainEnricher: PlainEnricher<T>;\n\n    constructor(CustomConstraint?: { new(...args): T }) {\n        this._constraint = (CustomConstraint || Constraints) as { new(...args): T };\n    }\n\n    configure(callback: DefineCallback<T>): Definition<T> {\n        const define = (path: string, definitions: T) => {\n            this._definitions[path] = new this._constraint(definitions);\n        };\n        const validate = (name, validator) => {\n            this._validators.push({name, validator})\n        };\n        const toPlainEnricher = (plainEnricher) => {\n            this._plainEnricher = plainEnricher;\n        };\n        callback(define, validate, toPlainEnricher);\n        return this;\n    }\n\n    model(): Model<T> {\n        return new Model(this._definitions, this._validators, this._plainEnricher);\n    }\n}\n\nexport class Model<T extends Constraints> {\n\n    private listeners = [] as any[];\n    private _fields = [] as Field<T>[];\n    private _validatorNames = [] as { name: string, validator: ((model: Model<T>) => Promise<boolean>) }[];\n    private _valid = undefined;\n    private _invalid = undefined;\n    private _plainEnricher = undefined as PlainEnricher<T>;\n\n    constructor(definitions: { [p: string]: T }, validators: { name: string, validator: ((model: Model<T>) => Promise<boolean>) }[], plainEnricher: PlainEnricher<T>) {\n        this._fields = Object.keys(definitions).map(key => {\n            const field = new Field(key, definitions[key]);\n            field.subscribe(() => this.runListeners());\n            return field;\n        });\n        this._validatorNames = validators;\n        this._plainEnricher = plainEnricher;\n    }\n\n    plainObj(): {[key:string]:any} {\n        const plainObj = {};\n        this._fields.filter(field => field.constraints.plainObject).forEach(field => {\n            //TODO: Dry this code\n            const paths = field.name.split(\".\");\n            const lastPath = paths.pop();\n            const target = paths.reduce((parentObj, path) => {\n                parentObj[path] = parentObj[path] === undefined ? {} : parentObj[path];\n                return parentObj[path];\n            }, plainObj);\n            target[lastPath] = field.value;\n        });\n        if (this._plainEnricher) {\n            //TODO: Dry this code\n            const enricher = this._plainEnricher(this);\n            const fieldNames = Object.keys(enricher);\n            fieldNames.forEach(fieldName => {\n                const paths = fieldName.split(\".\");\n                const lastPath = paths.pop();\n                const target = paths.reduce((parentObj, path) => {\n                    parentObj[path] = parentObj[path] === undefined ? {} : parentObj[path];\n                    return parentObj[path];\n                }, plainObj);\n                target[lastPath] = enricher[fieldName];\n            });\n        }\n        return plainObj;\n    }\n\n    prune() {\n        this._fields.forEach(it => it.prune());\n    }\n\n    load(data) {\n\n    }\n\n    clear() {\n\n    }\n\n    get valid() {\n        return this._valid;\n    }\n\n    get validatorNames() {\n        return this._validatorNames.map(it => it.name);\n    }\n\n    get fields() {\n        return this._fields;\n    }\n\n    get(fieldName): any {\n        return this._fields.find(it => it.name === fieldName).value;\n    }\n\n    setValid(toogle:boolean) {\n        this._valid = toogle;\n        this._invalid = !toogle;\n        this.runListeners();\n    }\n\n    setInvalid(toogle:boolean) {\n        this._valid = !toogle;\n        this._invalid = toogle;\n        this.runListeners();\n    }\n\n    subscribe(changeListener: (model: Model<T>) => void): Model<T> {\n        this.listeners.push(changeListener);\n        return this;\n    }\n\n    async validate(validationName?:string): Promise<boolean> {\n        if (validationName === undefined) {\n            const invalidFields = (await Promise.all(this._fields.map(async field => ({\n                name: field.name,\n                valid: await field.validate()\n            })))).filter(it => !it.valid);\n\n            if (invalidFields.length > 0) {\n                this.setValid(false);\n                return false;\n            }\n        }\n\n        const modelValidators = validationName ? this._validatorNames.filter(it => it.name == validationName) : this._validatorNames;\n        const invalidations = (await Promise.all(modelValidators.map(async it => ({\n            name: it.name,\n            valid: await it.validator(this)\n        })))).filter(it => !it.valid);\n\n        invalidations.forEach(it => {\n            console.debug(`Not validated by [${it.name}]`);\n        });\n\n        const isInvalid = invalidations.length > 0;\n        this.setInvalid(isInvalid);\n\n        return this.valid;\n    }\n\n    private runListeners() {\n        this.listeners.forEach(callback => callback(this));\n    }\n\n}\n\nconst primitivesProtos = [String, Number, Boolean, Symbol].map(it => it.prototype);\nconst isPrimitive = (constructor) => primitivesProtos.indexOf(constructor.prototype) > -1;\n\nexport class Field<T extends Constraints> {\n\n    private _value;\n    private _invalidReason = undefined;\n    private _invalid = undefined;\n    private _valid = undefined;\n    private _name: string;\n    private _dirty = undefined;\n    private _constraint = undefined as T;\n    private listeners = [] as Array<(field: Field<T>) => void>;\n\n    constructor(path: string, constraints: T) {\n        this._name = path;\n        this._constraint = constraints;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get value() {\n        if (this._value !== undefined) {\n            if (isPrimitive(this._constraint.type)) {\n                return (this._constraint.type as any)(this._value);\n            } else {\n                return new this._constraint.type(this._value)\n            }\n        }\n    }\n\n    get constraints() {\n        return this._constraint;\n    }\n\n    get invalid() {\n        return this._invalid;\n    }\n\n    get invalidReason() {\n        return this._invalidReason;\n    }\n\n    get valid() {\n        return this._valid;\n    }\n\n    get dirty() {\n        return this._dirty;\n    }\n\n    get required() {\n        return Boolean(this._constraint.required);\n    }\n\n    get cssState(): string {\n        const dirty = this._dirty && DefinitionCssState.dirty;\n        const invalid = this._invalid && DefinitionCssState.invalid;\n        const valid = this._valid && DefinitionCssState.valid;\n        return `${dirty || \"\"} ${invalid || \"\"} ${valid || \"\"}`.trim();\n    }\n\n    setValue(value: any) {\n        this._value = value;\n        this.setDirty(true);\n        this.runListeners();\n    }\n\n    subscribe(changeListener: ((field: Field<T>) => void)) {\n        this.listeners.push(changeListener);\n    }\n\n    prune() {\n        this._invalid = undefined;\n        this._valid = undefined;\n        this._invalidReason = undefined;\n        this.runListeners();\n    }\n\n    setDirty(toggle: boolean) {\n        this._dirty = toggle;\n        this.runListeners();\n    }\n\n    setInvalid(toggle: boolean) {\n        this._invalid = toggle;\n        this._valid = !toggle;\n        this.runListeners();\n    }\n\n    setValid(toggle: boolean) {\n        this._valid = toggle;\n        this._invalid = !toggle;\n        this.runListeners();\n    }\n\n    async validate(): Promise<boolean> {\n        try {\n            this._invalidReason = await this._constraint.validate(this._value);\n            const isValid = !Boolean(this._invalidReason);\n            if (!isValid) {\n                console.debug(`Not valid [${this.name}] reason [${this._invalidReason}]`);\n            }\n            this.setValid(isValid);\n            return isValid;\n        } catch (error) {\n            console.warn(`Error when validating field ${(this.name || \"\").toUpperCase()}\\n`, error, this);\n            this._invalidReason = `unknown error`;\n            this.setInvalid(true);\n            return false;\n        }\n    }\n\n    private runListeners() {\n        this.listeners.forEach(listener => listener(this));\n    }\n\n}\n","import {Definition} from \"../../core/_definition\";\n\nconst Person = new Definition().configure((define, validate, plainObjEnricher) => {\n\n    define(\"name\", {\n        type: String,\n        pattern: /\\w+ \\w+/,\n        required: true,\n    });\n\n    define(\"info.age\", {\n        type: Number,\n        pattern: /\\d{2}/,\n        extraValidation: async (value: Number) => Number(value) >= 18\n    });\n\n    define(\"info.birth\", {\n        type: Date,\n        extraValidation: async (value:any) => new Date(value).getSeconds() % 2 === 0\n    });\n\n    define(\"bank.number\", {\n        type: Number,\n        required: true,\n        pattern: /^\\d{4}$/,\n        plainObject: false\n    });\n\n    define(\"bank.digit\", {\n        type: Number,\n        required: true,\n        pattern: /^\\d{1}$/,\n        plainObject: false\n    });\n\n    define(\"country\", {\n        //TODO: Implement options (<select>)\n    });\n\n    validate(\"default\", async (): Promise<boolean> => {\n        return true;\n    });\n\n    validate(\"bank\", async (model): Promise<boolean> => {\n        return model.get(\"bank.digit\") > 5;\n    });\n\n    plainObjEnricher(model => {\n        return {\n            \"info.bank\": model.get(\"bank.number\") && model.get(\"bank.digit\") && `${model.get(\"bank.number\")}${model.get(\"bank.digit\")}`\n        }\n    });\n\n});\n\nexport {Person}\n","import {customElement, html, property} from \"lit-element\";\nimport {Person} from \"../../application/definitions/person\";\nimport {PageElement} from \"../page-element\";\n\n@customElement(\"page-form\")\nclass FormPage extends PageElement {\n\n    @property()\n    person = Person.model().subscribe(() => this.requestUpdate());\n\n    protected render() {\n        const {person} = this;\n\n        return html`\n            <div class=\"l-pad-10\">\n                <div class=\"l-row\">\n                    <div>\n                        ${person.fields.map(field => html`\n                            <div class=\"field\">\n                                <div>field: ${field.name}</div>\n                                <input class=\"${field.cssState}\" @input=${e => field.setValue(e.target.value || undefined)} @blur=${e => field.validate()}>\n                                <div>\n                                    <div><strong>css</strong>: ${field.cssState}</div>\n                                    <div><strong>required</strong>: ${field.required.toString()}</div>\n                                    <div><strong>reason</strong>: ${field.invalidReason}</div>\n                                    <div><strong>valid</strong>: ${field.valid}</div>\n                                    <div><strong>dirty</strong>: ${field.dirty}</div>\n                                </div>\n                            </div>\n                            <br>\n                        `)}\n                        <button @click=${() => person.validate()}>Enviar</button>\n                    </div>\n                    \n                    <div style=\"position: sticky; top: 1px;\">\n                        <div><strong>Model validators</strong>:<br> ${person.validatorNames.join(\", \")}</div><br>\n                        <div><strong>Model valid</strong>:<br> ${person.valid}</div><br>\n                        <div><strong>Plain Obj:</strong></div>\n                        <pre>${\n                            JSON.stringify(person.plainObj(), null, 2)\n                        }</pre>\n                    </div>\n                    \n                </div>\n            </div>    \n        `;\n    }\n\n\n    protected createRenderRoot() {\n        return this;\n    }\n}\n"]}